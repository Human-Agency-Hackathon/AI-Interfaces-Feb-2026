# Export / Structured Report Format

**Task 53 | Owner: Jeff | Status: Complete**

This document defines the full export contract for a completed brainstorming session: when export happens, the exact markdown shape, the TypeScript data model, the assembly logic, and how the file reaches the user's hands.

---

## 1. Export Trigger

Export can happen in two ways:

### Automatic trigger
When the Presentation stage completes (`stage:completed` with `isFinal: true`), the server automatically assembles the `ExportReport` object and stores it in the session's `ProcessState`. The server does **not** push the file to the client automatically — it waits for an explicit request. This ensures the user gets to review the live presentation first before downloading.

### Manual trigger (`/export` command)
The human types `/export` in the prompt bar at any point after Presentation completes (or, if `human_gates: false`, after the process reaches `status: 'completed'`). This fires a `player:export` WebSocket message to the server, which responds with `session:exported` carrying the rendered markdown string.

If `/export` is requested before Presentation completes, the server responds with an `error` message: `"Export is not available until the Presentation stage completes."` and continues the session normally.

**Design choice:** Do not auto-push the download. Let the human decide when to export. The session may still be in progress (revision loop back to Review), and an unwanted auto-download would be disruptive.

---

## 2. Export Format: Markdown Report

The report has six sections. Here is the exact template followed by a filled-in example.

### Template

```markdown
# Brainstorm Report: {problem_statement}

**Date:** {YYYY-MM-DD}
**Template:** {process_name}
**Duration:** {duration_minutes} minutes ({stage_count} stages)

---

## Recommendation

{recommendation_text}

---

## Supporting Ideas (Top 3)

### 1. {idea_1_title}
**Score:** {idea_1_score} / 10
{idea_1_rationale}

### 2. {idea_2_title}
**Score:** {idea_2_score} / 10
{idea_2_rationale}

### 3. {idea_3_title}
**Score:** {idea_3_score} / 10
{idea_3_rationale}

---

## Why This Works

- {why_1}
- {why_2}
- {why_3}

---

## How to Start

1. {step_1}
2. {step_2}
3. {step_3}

---

## Risks We're Aware Of

- **{risk_1_label}:** {risk_1_description}
- **{risk_2_label}:** {risk_2_description}

---

## What We Considered and Didn't Choose

- **{alt_1_title}:** {alt_1_reason}
- **{alt_2_title}:** {alt_2_reason}

---

## What Was Generated and Discarded

{discarded_count} ideas were generated across all stages. The following were eliminated during stress-testing:

{discarded_list}

---

## Agent Roster

| Agent | Role | Stages Active |
|-------|------|---------------|
{agent_rows}

---

## Stage Timeline

| Stage | Status | Key Artifacts |
|-------|--------|---------------|
{stage_rows}

---

*Generated by Agent Dungeon brainstorm session on {date}.*
```

---

### Filled-In Example

The demo problem: **"Generate ideas for a new web agent"**

```markdown
# Brainstorm Report: Generate ideas for a new web agent

**Date:** 2026-02-21
**Template:** Deep Brainstorm (7 stages)
**Duration:** 9 minutes (7 stages)

---

## Recommendation

Build a **Ambient Context Agent** — a persistent browser extension that passively observes the user's browsing and work patterns, builds a structured knowledge graph in the background, and surfaces proactive suggestions exactly when they're relevant, without requiring the user to prompt it.

---

## Supporting Ideas (Top 3)

### 1. Ambient Context Agent
**Score:** 8.35 / 10
Wins on Impact (9) and Novelty (9): no existing tool passively observes cross-tab context to build a persistent model. Feasibility is strong — browser extensions have full DOM access and existing LLM APIs make the inference layer tractable. The Cross-Pollinator sourced the core mechanism from ant pheromone trail systems (indirect stigmergy).

### 2. Collaborative Research Mesh
**Score:** 7.60 / 10
Multiple agents share a live semantic graph of what they've each discovered; each agent's findings enrich the shared map in real time. High on Impact (8) and Novelty (8). Execution risk is real — keeping graph consistency across concurrent agents is a known distributed systems problem, but the precedent from collaborative editing tools (Notion, Figma) shows it's solvable.

### 3. Prompt Diff Debugger
**Score:** 7.15 / 10
An agent that specializes in explaining *why* a prompt produced a given output by running systematic ablations. High Feasibility (9) because the mechanism is purely compositional — no new capabilities needed. Lower Novelty (6) since prompt testing tools exist, but none frame it as an interactive agent conversation.

---

## Why This Works

- Users already have context scattered across tabs, docs, and chat threads — a passive observer removes the burden of explicit context-sharing that every current agent requires.
- The browser extension distribution model means zero infrastructure on the user's side; the agent runs where the work already happens.
- Ant colony stigmergy (indirect coordination via environment state) has been proven at massive scale; applying it to knowledge accumulation transfers cleanly because both problems are fundamentally about emergent structure from local observations.

---

## How to Start

1. Build a minimal browser extension that captures page titles, selected text, and dwell time into a local SQLite store — no LLM calls yet.
2. Add a background embedding pass every 5 minutes that clusters the stored observations into named topics.
3. Wire a small LLM call that fires when the user opens a new tab and the local graph has high-confidence context relevant to the new URL.
4. User-test the proactive nudge pattern with 5 people; measure whether suggestions feel helpful or intrusive.
5. Add opt-out controls and a "show me what you know about me" transparency view before any wider release.

---

## Risks We're Aware Of

- **Privacy and trust:** Passive observation of all browsing is intrinsically sensitive. Users must consent explicitly, see exactly what is stored, and control deletion. Rushing to ship without a transparent data model will trigger immediate backlash.
- **Relevance precision:** A proactive agent that interrupts with low-relevance suggestions will be disabled within a day. The threshold for "surfacing a suggestion" must be very high; better to miss than to annoy. Invest heavily in precision before recall.

---

## What We Considered and Didn't Choose

- **Codebase Navigator Agent:** An agent that maintains a live map of a software repository and answers questions about it in natural language. Strong Feasibility (9), but low Novelty (5) — tools like GitHub Copilot Chat and Sourcegraph Cody already occupy this space.
- **Multi-Agent Debate Engine:** A team of specialized agents that argue opposing positions on any question the user poses, synthesizing a structured verdict. High Novelty (8), but the Skeptic flagged a FATAL feasibility issue: coordinating adversarial agent turns without circular loops requires a conductor architecture that doesn't exist in any accessible framework today.

---

## What Was Generated and Discarded

28 ideas were generated across Divergent Thinking. The following were eliminated during Convergent, Fact Checking, or Pushback:

- **Context Harvester Chrome Extension** — merged into Ambient Context Agent (same mechanism, weaker framing)
- **AI-Powered RSS Feed Curator** — low Novelty (3); well-covered by existing tools
- **Distributed Agent Swarm for Research** — FATAL: Feasibility Analyst rated economic dimension BLOCKER (coordination overhead exceeds value at accessible compute costs)
- **Reverse-Prompt Generator** — Devil's Advocate verdict: KILLED. The strongest attack ("users don't want to think in prompts — they want outcomes") was not survivable; the idea is a tool for prompt engineers, not a general web agent
- **Browser Automation Recorder** — WEAKENED but not selected; Pragmatist identified Selenium/Playwright ecosystem as near-insurmountable competition
- **Semantic Bookmark Manager** — low Impact (4); solves a minor friction point, not a core user pain
- **Agent-to-Agent Marketplace** — high Novelty (9) but FATAL: regulatory rating BLOCKER (agent-as-service with financial transactions triggers payment processor rules and potential financial services regulation in 3 jurisdictions)

---

## Agent Roster

| Agent | Role | Stages Active |
|-------|------|---------------|
| The Cartographer | Problem Framing — maps scope and constraints | Problem Framing |
| The Questioner | Problem Framing — challenges assumptions | Problem Framing |
| The Wild Ideator | Divergent — generates ideas without filtering | Divergent Thinking |
| The Cross-Pollinator | Divergent — imports mechanisms from other domains | Divergent Thinking |
| The Synthesizer | Convergent — clusters ideas, selects strongest per cluster | Convergent Thinking |
| The Connector | Convergent — proposes hybrid combinations | Convergent Thinking |
| The Skeptic | Critique — rates assumption reliability, flags FATAL ideas | Critique |
| The Devil's Advocate | Critique — finds strongest counterargument per idea | Critique |
| The Strategist | Prioritization — scores and ranks surviving candidates | Prioritization |
| The Architect | Synthesis — weaves top ideas into a coherent proposal | Synthesis |
| The Narrator | Presentation — formats the final deliverable | Presentation |

---

## Stage Timeline

| Stage | Status | Key Artifacts |
|-------|--------|---------------|
| Problem Framing | Complete | Framing doc: scope defined as "browser-based, single-user, no existing infrastructure required"; key constraint: must work without custom server |
| Divergent Thinking | Complete | 28 ideas generated across 2 agents; groupthink prevented via hard isolation |
| Convergent Thinking | Complete | Reduced to 8 candidates: 5 from Synthesizer clusters, 3 hybrid combinations from Connector |
| Critique | Complete | 2 FATAL eliminations (Distributed Swarm, Agent Marketplace); 3 WEAKENED, 3 STRONG survivors |
| Prioritization | Complete | Ranked list produced; top 3 approved by human |
| Synthesis | Complete | Coherent proposal document produced by The Architect |
| Presentation | Complete | Final formatted deliverable delivered by The Narrator |

---

*Generated by Agent Dungeon brainstorm session on 2026-02-21.*
```

---

## 3. TypeScript Type: `ExportReport`

This interface lives in `shared/` alongside `process.ts`. It is the structured data model that `buildExportReport()` returns. The markdown renderer uses this as input.

```typescript
// shared/export.ts

/**
 * A single ranked idea from the Prioritization stage.
 */
export interface ExportRankedIdea {
  rank: number;
  title: string;
  /** Weighted score from Prioritization stage (0.0–10.0) */
  score: number;
  /** One-sentence rationale from The Strategist */
  rationale: string;
  /** Individual dimension scores, if available */
  scores?: {
    impact: number;
    feasibility: number;
    novelty: number;
    speed: number;
    risk_inverse: number;
  };
}

/**
 * An idea that was generated but not selected in the final recommendation.
 */
export interface ExportDiscardedIdea {
  title: string;
  /** The stage at which this idea was eliminated */
  eliminatedAt: 'convergent' | 'fact_check' | 'pushback' | 'prioritization';
  /** One sentence on why it was dropped */
  reason: string;
}

/**
 * One agent that participated in the session.
 */
export interface ExportAgentEntry {
  roleId: string;
  roleName: string;
  /** Short description of the role's purpose */
  description: string;
  /** Stage IDs this agent was active in */
  activeStages: string[];
}

/**
 * One stage in the stage timeline.
 */
export interface ExportStageEntry {
  stageId: string;
  stageName: string;
  /** 'complete' for all finished stages, 'skipped' for optional stages that were bypassed */
  status: 'complete' | 'skipped';
  /** Human-readable summary of what this stage produced */
  artifactSummary: string;
}

/**
 * The full structured export report.
 * Produced by buildExportReport() and rendered to markdown for download.
 */
export interface ExportReport {
  // ── Header ─────────────────────────────────────────
  problem: string;
  date: string;               // ISO date string, e.g. "2026-02-21"
  templateId: string;         // e.g. "deep_brainstorm"
  templateName: string;       // e.g. "Deep Brainstorm (7 stages)"
  durationMinutes: number;    // wall-clock minutes from startedAt to completedAt
  stageCount: number;         // number of stages that ran (excluding skipped)

  // ── Recommendation ─────────────────────────────────
  /** Full recommendation text from the Presentation stage (The Narrator's output) */
  recommendation: string;

  /** The three "Why This Works" bullet points from Presentation */
  whyItWorks: string[];

  /** The ordered "How to Start" steps from Presentation */
  howToStart: string[];

  /** Risks and mitigations from Presentation */
  risks: Array<{
    label: string;
    description: string;
  }>;

  // ── Ideas ───────────────────────────────────────────
  /** Top 3 ideas from Prioritization, in ranked order */
  topIdeas: ExportRankedIdea[];

  /** Alternatives that were considered but not chosen (from Presentation's "What We Considered" section) */
  alternatives: Array<{
    title: string;
    reason: string;
  }>;

  /** Ideas generated but eliminated before Prioritization */
  discardedIdeas: ExportDiscardedIdea[];

  /** Total count of raw ideas generated in Divergent Thinking */
  totalIdeasGenerated: number;

  // ── Agents ─────────────────────────────────────────
  agents: ExportAgentEntry[];

  // ── Stages ─────────────────────────────────────────
  stages: ExportStageEntry[];
}
```

---

## 4. Assembly Logic

The function signature and field sources:

```typescript
// server/src/ExportBuilder.ts

import type { ProcessState, ProcessDefinition } from '../../shared/process.js';
import type { FindingsBoard } from './FindingsBoard.js';
import type { ExportReport, ExportRankedIdea, ExportDiscardedIdea, ExportAgentEntry, ExportStageEntry } from '../../shared/export.js';

/**
 * Assembles a structured ExportReport from all available session state.
 *
 * Sources:
 *   processState      — problem, startedAt, completedAt, collectedArtifacts
 *   processDefinition — stage names, role names, role descriptions
 *   findingsBoard     — not used for the report body (artifacts are richer),
 *                       but can supply agent-level notes for the roster
 */
export function buildExportReport(
  processState: ProcessState,
  processDefinition: ProcessDefinition,
  findingsBoard: FindingsBoard,  // reserved for future per-agent summary enrichment
): ExportReport {

  const { problem, startedAt, completedAt, collectedArtifacts } = processState;

  // ── Duration ────────────────────────────────────────────────────────────────
  const startMs = new Date(startedAt).getTime();
  const endMs   = completedAt ? new Date(completedAt).getTime() : Date.now();
  const durationMinutes = Math.round((endMs - startMs) / 60_000);

  // ── Presentation artifact ────────────────────────────────────────────────────
  // The Narrator's final output lives at:
  //   collectedArtifacts["presentation"]["final_output"]
  //
  // The Narrator is instructed (via system prompt) to produce structured sections
  // separated by heading markers. We parse those sections out here.
  const presentationArtifact = collectedArtifacts['presentation']?.['final_output'] ?? '';

  const recommendation = extractSection(presentationArtifact, 'The Recommendation');
  const whyItWorks     = extractBullets(presentationArtifact, 'Why This Works');
  const howToStart     = extractNumberedList(presentationArtifact, 'How to Start');
  const risks          = extractRisks(presentationArtifact, 'Risks We\'re Aware Of');
  const alternatives   = extractAlternatives(presentationArtifact, 'What We Considered and Didn\'t Choose');

  // ── Prioritization artifact ─────────────────────────────────────────────────
  // The Strategist's ranked list lives at:
  //   collectedArtifacts["prioritization"]["ranked_list"]
  //
  // Expected format matches the JSON schema in DESIGN.md §8.
  const rankedListRaw = collectedArtifacts['prioritization']?.['ranked_list'] ?? '';
  const topIdeas: ExportRankedIdea[] = parseTopIdeas(rankedListRaw).slice(0, 3);

  // ── Discarded ideas ─────────────────────────────────────────────────────────
  // Sources in priority order:
  //   1. collectedArtifacts["critique"]["critique_notes"]  — FATAL / KILLED verdicts
  //   2. collectedArtifacts["convergent_thinking"]["candidate_list"] — ideas clustered out
  //
  // The convergent artifact lists raw idea count; the critique notes list eliminations.
  const critiqueArtifact   = collectedArtifacts['critique']?.['critique_notes'] ?? '';
  const convergentArtifact = collectedArtifacts['convergent_thinking']?.['candidate_list'] ?? '';
  const divergentArtifact  = collectedArtifacts['divergent_thinking']?.['idea_list'] ?? '';

  const discardedIdeas: ExportDiscardedIdea[] = parseDiscardedIdeas(critiqueArtifact, convergentArtifact);
  const totalIdeasGenerated = countIdeas(divergentArtifact);

  // ── Agent roster ────────────────────────────────────────────────────────────
  // Derived entirely from ProcessDefinition.roles and ProcessDefinition.stages.
  // No runtime data needed — the roster is structural, not behavioral.
  const agents: ExportAgentEntry[] = processDefinition.roles.map((role) => {
    const activeStages = processDefinition.stages
      .filter((stage) => stage.roles.includes(role.id))
      .map((stage) => stage.name);

    return {
      roleId:       role.id,
      roleName:     role.name,
      description:  role.persona,
      activeStages,
    };
  });

  // ── Stage timeline ───────────────────────────────────────────────────────────
  // Each stage is 'complete' if its artifacts exist in collectedArtifacts, else 'skipped'.
  // Artifact summary is the first 120 characters of the stage's first artifact, or a fallback.
  const stages: ExportStageEntry[] = processDefinition.stages.map((stage) => {
    const stageArtifacts = collectedArtifacts[stage.id];
    const hasArtifacts = stageArtifacts && Object.keys(stageArtifacts).length > 0;

    const firstArtifactContent = hasArtifacts
      ? Object.values(stageArtifacts)[0]
      : '';
    const artifactSummary = firstArtifactContent
      ? firstArtifactContent.slice(0, 120).replace(/\n/g, ' ') + '…'
      : '(no artifact recorded)';

    return {
      stageId:         stage.id,
      stageName:       stage.name,
      status:          hasArtifacts ? 'complete' : 'skipped',
      artifactSummary,
    };
  });

  // ── Assemble ─────────────────────────────────────────────────────────────────
  return {
    problem,
    date:           new Date(startedAt).toISOString().slice(0, 10),
    templateId:     processDefinition.id,
    templateName:   `${processDefinition.name} (${processDefinition.stages.length} stages)`,
    durationMinutes,
    stageCount:     stages.filter((s) => s.status === 'complete').length,

    recommendation,
    whyItWorks,
    howToStart,
    risks,

    topIdeas,
    alternatives,
    discardedIdeas,
    totalIdeasGenerated,

    agents,
    stages,
  };
}

// ── Parsing helpers (pseudo-implementation) ──────────────────────────────────
//
// Each helper operates on the Narrator's free-text output, using the
// section headers the Narrator is instructed to produce as anchors.
// A real implementation uses regex or a lightweight markdown parser.
// The Narrator's system prompt enforces consistent heading names.

function extractSection(text: string, heading: string): string {
  // Returns the paragraph(s) between `### {heading}` and the next `###`
  const pattern = new RegExp(`###\\s*${heading}\\s*\\n([\\s\\S]*?)(?=###|$)`, 'i');
  return text.match(pattern)?.[1]?.trim() ?? '';
}

function extractBullets(text: string, heading: string): string[] {
  const section = extractSection(text, heading);
  return section.split('\n').filter((l) => l.startsWith('- ')).map((l) => l.slice(2).trim());
}

function extractNumberedList(text: string, heading: string): string[] {
  const section = extractSection(text, heading);
  return section.split('\n').filter((l) => /^\d+\./.test(l)).map((l) => l.replace(/^\d+\.\s*/, '').trim());
}

function extractRisks(text: string, heading: string): Array<{ label: string; description: string }> {
  const section = extractSection(text, heading);
  // Expects: "- **Label:** Description"
  const pattern = /- \*\*(.+?):\*\*\s*(.+)/g;
  const results: Array<{ label: string; description: string }> = [];
  for (const match of section.matchAll(pattern)) {
    results.push({ label: match[1], description: match[2].trim() });
  }
  return results;
}

function extractAlternatives(text: string, heading: string): Array<{ title: string; reason: string }> {
  const section = extractSection(text, heading);
  // Expects: "- **Title:** Reason"
  const pattern = /- \*\*(.+?):\*\*\s*(.+)/g;
  const results: Array<{ title: string; reason: string }> = [];
  for (const match of section.matchAll(pattern)) {
    results.push({ title: match[1], reason: match[2].trim() });
  }
  return results;
}

function parseTopIdeas(rankedListRaw: string): ExportRankedIdea[] {
  // The Strategist produces JSON conforming to DESIGN.md §8 Prioritization output format.
  // Try JSON parse first; fall back to regex if the model emitted wrapped text.
  try {
    const parsed = JSON.parse(rankedListRaw);
    return (parsed.rankings ?? []).map((r: any) => ({
      rank:      r.rank,
      title:     r.title,
      score:     r.weighted_total,
      rationale: r.rationale,
      scores:    r.scores,
    }));
  } catch {
    return [];  // Return empty on parse failure; markdown renderer handles gracefully
  }
}

function parseDiscardedIdeas(critiqueArtifact: string, convergentArtifact: string): ExportDiscardedIdea[] {
  // FATAL and KILLED verdicts appear in critique notes as:
  //   "Candidate N | Status: FATAL | ..." or "Candidate N | ... | Verdict: KILLED | ..."
  // This is a best-effort parse; imprecise extractions are acceptable here.
  const results: ExportDiscardedIdea[] = [];

  for (const line of critiqueArtifact.split('\n')) {
    if (/FATAL/i.test(line)) {
      const titleMatch = line.match(/Candidate\s+\d+:\s*([^|]+)/i);
      if (titleMatch) {
        results.push({
          title: titleMatch[1].trim(),
          eliminatedAt: 'fact_check',
          reason: 'Marked FATAL: core assumption rated FALSE by The Skeptic or feasibility dimension rated BLOCKER',
        });
      }
    } else if (/KILLED/i.test(line)) {
      const titleMatch = line.match(/Candidate\s+\d+:\s*([^|]+)/i);
      if (titleMatch) {
        results.push({
          title: titleMatch[1].trim(),
          eliminatedAt: 'pushback',
          reason: 'Verdict: KILLED by Devil\'s Advocate — strongest counterargument not survivable',
        });
      }
    }
  }

  return results;
}

function countIdeas(divergentArtifact: string): number {
  // Ideas are numbered list items in the divergent artifact.
  const matches = divergentArtifact.match(/^\d+\./gm);
  return matches?.length ?? 0;
}
```

**Key field-to-source mapping summary:**

| Report field | Source |
|---|---|
| `problem` | `processState.problem` |
| `date`, `durationMinutes` | `processState.startedAt`, `processState.completedAt` |
| `templateId`, `templateName`, stage count | `processDefinition.id`, `.name`, `.stages.length` |
| `recommendation`, `whyItWorks`, `howToStart`, `risks`, `alternatives` | `collectedArtifacts["presentation"]["final_output"]` — parsed by heading |
| `topIdeas` (scores, rationale) | `collectedArtifacts["prioritization"]["ranked_list"]` — JSON parsed |
| `discardedIdeas` | `collectedArtifacts["critique"]["critique_notes"]` — FATAL/KILLED lines |
| `totalIdeasGenerated` | `collectedArtifacts["divergent_thinking"]["idea_list"]` — numbered list count |
| `agents` (roster) | `processDefinition.roles` + `.stages[*].roles` (structural, no runtime data) |
| `stages` (timeline) | `processDefinition.stages` + `collectedArtifacts` keyed by stage ID |

---

## 5. Delivery Mechanism

### Options considered

**(a) Server writes a `.md` file to disk and sends a download URL**
Server writes to e.g. `./exports/{sessionId}-{date}.md` and sends the path via WebSocket. Client opens the URL in a new tab.

**Drawback:** Requires the server to be accessible over HTTP for file serving, and creates file-system clutter. Works locally but breaks in multi-tenant or serverless deployments. Also requires CORS configuration if the origin differs.

**(b) Server sends the markdown string via WebSocket; client triggers a browser download**
Server renders the markdown string, sends it in a `session:exported` message. Client receives the string, wraps it in a `Blob`, creates a temporary object URL, clicks it, and revokes it.

**Drawback:** Markdown string goes over the WebSocket, which has a per-message size limit (configurable, defaults to ~1 MB in most WS servers). A typical brainstorm report is ~3–8 KB. Not a real concern.

**(c) Client builds the markdown from state it already has**
The client receives `stage:completed` messages with artifact content. It accumulates them and renders locally when the user types `/export`.

**Drawback:** The client would need to re-implement all the parsing and assembly logic that the server already has access to. The `ExportReport` assembly logic needs access to `ProcessDefinition` and `ProcessState` together — the client only has partial visibility. Also, any future enrichment (e.g., token cost summaries, agent transcript excerpts) would require additional server-side data.

### Recommendation: Option (b)

Server renders markdown, sends via WebSocket, client triggers browser download.

**Reasons:**
1. Assembly logic lives where all data lives (server has `ProcessState`, `ProcessDefinition`, and `FindingsBoard`). No data duplication to client.
2. The WebSocket connection is already the sole communication channel — no new endpoints needed.
3. Browser-side blob download is four lines of code and produces a clean `.md` file named after the problem statement.
4. The rendered markdown is human-readable and can also be copy-pasted from the message payload for debugging.

---

## 6. Protocol Addition

Two new messages are needed: one player-to-server request and one server-to-all response.

### `player:export` (Player → Server)

```typescript
/**
 * Player requests an export of the current session.
 * Valid only after the Presentation stage completes.
 * Server responds with session:exported (success) or error (if process not complete).
 */
export interface ExportSessionMessage {
  type: 'player:export';
}
```

No payload needed. The server resolves the session from the WebSocket connection context.

### `session:exported` (Server → Client)

```typescript
/**
 * Server responds to player:export with the rendered markdown and structured data.
 * Client should trigger a browser file download using the markdown string.
 *
 * Suggested filename: brainstorm-{slugified problem}-{date}.md
 * Example: brainstorm-generate-ideas-for-a-new-web-agent-2026-02-21.md
 */
export interface SessionExportedMessage {
  type: 'session:exported';
  /** ISO date string */
  date: string;
  /** The problem statement, for use in the suggested filename */
  problem: string;
  /** Fully rendered markdown report, ready to write to a .md file */
  markdown: string;
  /** Structured report data, for any client-side rendering or logging */
  report: ExportReport;
}
```

### Client-side download (four lines)

```typescript
function triggerMarkdownDownload(problem: string, date: string, markdown: string): void {
  const slug = problem.toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 60);
  const filename = `brainstorm-${slug}-${date}.md`;
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
```

### Protocol union additions

Add to `ClientMessage` in `shared/protocol.ts`:
```typescript
| ExportSessionMessage
```

Add to `ServerMessage` in `shared/protocol.ts`:
```typescript
| SessionExportedMessage
```

---

## Summary of New Files / Changes

| File | Action | What |
|------|--------|------|
| `shared/export.ts` | **Create** | `ExportReport` and sub-interfaces |
| `server/src/ExportBuilder.ts` | **Create** | `buildExportReport()` function |
| `shared/protocol.ts` | **Edit** | Add `ExportSessionMessage`, `SessionExportedMessage`, extend union types |
| `server/src/MessageHandler.ts` (or equivalent) | **Edit** | Handle `player:export` → call `buildExportReport()` → render markdown → send `session:exported` |
| `client/src/` (GameView or equivalent) | **Edit** | On `session:exported`, call `triggerMarkdownDownload()` |

The markdown renderer (ExportReport → string) is a straightforward template function and does not need its own file — it can live as a private function in `ExportBuilder.ts`.

---

*Task 53 complete. Design by Jeff's agent, 2026-02-21.*
